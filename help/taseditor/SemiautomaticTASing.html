<html>
	
<head>
	<title>4.3. Semiautomatic TASing</title>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="generator" content="HelpNDoc Personal Edition 3.8.0.560">
	<link type="text/css" rel="stylesheet" media="all" href="css/reset.css" />
	<link type="text/css" rel="stylesheet" media="all" href="css/base.css" />
	<link type="text/css" rel="stylesheet" media="all" href="css/hnd.css" />
	<!--[if lte IE 8]>
		<link type="text/css" rel="stylesheet" media="all" href="css/ielte8.css" />
	<![endif]-->
	<style type="text/css">
		#topic_header
		{
			background-color: #EFEFEF;
		}
	</style>
	<script type="text/javascript" src="js/jquery.min.js"></script>
	<script type="text/javascript" src="js/hnd.js"></script>
	<script type="text/javascript">
		$(document).ready(function()
		{
			if (top.frames.length == 0)
			{
				var sTopicUrl = top.location.href.substring(top.location.href.lastIndexOf("/") + 1, top.location.href.length);
				top.location.href = "index.html?" + sTopicUrl;
			}
			else if (top && top.FrameTOC && top.FrameTOC.SelectTocItem)
			{
				top.FrameTOC.SelectTocItem("SemiautomaticTASing");
			}
		});
	</script>
</head>

<body>

	<div id="topic_header">
			<div id="topic_header_content">
				<h1>4.3. Semiautomatic TASing</h1>
				
				<div id="topic_breadcrumb">
					<a href="BeginnersGuide.html">Beginner's Guide</a> &rsaquo;&rsaquo; <a href="TASingMethodology.html">4. TASing Methodology</a> &rsaquo;&rsaquo; </div>
				</div>
			<div id="topic_header_nav">
				<a href="TASingMethodology.html"><img src="img/arrow_up.png" alt="Parent"/></a>
				
				<a href="NonlinearTASing.html"><img src="img/arrow_left.png" alt="Previous"/></a>
				
				<a href="ProgramCustomization.html"><img src="img/arrow_right.png" alt="Next"/></a>
				
				</div>
			<div class="clear"></div>
		</div>
	<div id="topic_content">
		
<p></p>
<p><span class="rvts19">Semiautomatic TASing</span></p>
<p class="rvps10"><span class="rvts21"><br/></span></p>
<p class="rvps10"><span class="rvts21"><br/></span></p>
<p class="rvps10"><img align="right" alt="" style="padding : 6px;" src="lib/toolbox-method3.png"/></p>
<p class="rvps10"><span class="rvts21">This method further develops the ideas of the nonlinear TASing method.</span></p>
<p class="rvps10"><span class="rvts21">In many cases TASer needs to see the result of the Input modification immediately. Ideally, he should realize all the consequences of his decision right at the moment of making the decision. But in reality he has to spend precious time on inputting the decision and navigating with the Playback cursor to the end of the segment.</span></p>
<p class="rvps10"><span class="rvts21">In these cases you can leave the Playback navigation to Taseditor and just focus on editing. Taseditor will immediately react on any Input modification and display the new result.by bringing the Playback cursor to the end of the current segment.</span></p>
<p class="rvps10"><span class="rvts21">When you feel the influence of every click, you build very high level of interconnection between TASer and the game. In such close interaction both TASer controls the game and the game urges TASer's actions into right direction. Of course, such high level of interdependency is not always useful, because it narrows your spectrum of thoughts, not allowing to look down on the game and apply a logic from different games and other fields of life.</span></p>
<p class="rvps10"><span class="rvts21">However, when the current segment is simple and all optimality factors are already known (and you only need to find the perfect combination of them), it's useful to abstract from everything else and devote full attention to going over the possible options. This way you can test a lot of approaches before you become bored with the current segment.</span></p>
<p class="rvps10"><span class="rvts21">The Recording mode should be off. The </span><span class="rvts21">"Auto-restore last position" checkbox should be on. </span><span class="rvts21">The "Turbo seek" and "Follow cursor" checkboxes are usually disabled, but may be enabled when necessary.</span></p>
<p class="rvps10"><span class="rvts21"><br/></span></p>
<p class="rvps10"><span class="rvts22">General activity:</span></p>
<p class="rvps10"><span class="rvts48"><br/></span></p>
<ol style="text-indent: 30px; margin-left: 0px; list-style-position: inside;">
<li class="rvps10"><span class="rvts21">Scroll the Piano Roll to the beginning of the edited segment, put the Playback cursor here, define the goal.</span></li>
<li class="rvps10"><span class="rvts21">Detect the end of the segment and leave the Playback cursor there.</span></li>
<li class="rvps10"><span class="rvts21">Suppose there's a mistake in the segment, weigh known factors of optimality and figure out the way to fix the mistake.</span></li>
<li class="rvps10"><span class="rvts21">The mouse cursor navigation to any frame of the current segment is practically instant.</span></li>
<li class="rvps10"><span class="rvts21">Edit the segment with the mouse. After every Input modification the Playback cursor will automatically replay the segment and stop at the frame that was considered to be the end of the segment. If necessary, you can shift the end of the segment by moving the Playback cursor manually (e.g. using the mouse wheel). The steps 4 and 5 are constantly alternating until you consider the editing complete, according to the optimality criterion.</span></li>
<li class="rvps10"><span class="rvts21">[</span><span class="rvts34">optional step</span><span class="rvts21">] Save the finished approach to any free Bookmark, e.g. to slot </span><span class="rvts26">8</span><span class="rvts21"> or </span><span class="rvts26">7</span><span class="rvts21">.</span></li>
<li class="rvps10"><span class="rvts21">If this isn't the first approach to the segment, compare the new result to the best old result, using the optimality criterion. If the new approach is better (or it's the first approach), save the result to the Bookmark </span><span class="rvts26">9</span><span class="rvts21">. The slot </span><span class="rvts26">9</span><span class="rvts21"> will be used for keeping the best result of polishing the segment.</span></li>
<li class="rvps10"><span class="rvts21">If you still want to try different series of approaches, return to step 3, until you run out of ideas.</span></li>
<li class="rvps10"><span class="rvts21">[</span><span class="rvts34">optional step</span><span class="rvts21">] If you need more ideas, you can get some information from the past or the future by moving the Playback cursor to different segments of the movie or unpausing the emulator. When necessary, you can quickly draw a rough Input for watching the upcoming events of the game. But when returning to the segment modification you have to return the Playback cursor to the frame of the target event.</span></li>
<li class="rvps10"><span class="rvts21">When there's no more ideas, restore the best approach from the History Log or the Bookmark </span><span class="rvts26">9</span><span class="rvts21"> into the current movie and proceed to the next segment.</span></li>
</ol>
<p class="rvps10"><span class="rvts21"><br/></span></p>
<hr style="height: 1px; color : #000000;  background-color : #000000; border-width : 0px;"/>
<p class="rvps10"><span class="rvts21"><br/></span></p>
<p class="rvps10"><span class="rvts21">The main difference between this and previous method is that here the Playback cursor is generally located at the end of the current segment, and not at the beginning. Every time the Greenzone truncates, the Playback cursor seeks to the end of the segment, or rather to the frame where the segment end was before you modified the Input. If the Input modification also changed the frame of the target event, you can additionally move the light-blue cursor by mouse wheel if needed. But often there's no need for precise positioning, because you may only need to know the sequence of events occurring in the segment due to the Input modification.</span></p>
<p class="rvps10"><span class="rvts21">The replay of the current segment is automatically launched after every interim step of the Input modifications, even when you haven't finished the thought yet and are not ready to compare the current result to the result of the previous approach. Fortunately, when TASer is carried away by the editing process, he doesn't look at FCEUX screen and only clicks the Piano Roll, until his idea is implemented in the form of a full-fledged button combination. And when the Input is starting to become interesting, TASer pays attention to the emulator screen or the Memory Watch window.</span></p>
<p class="rvps10"><span class="rvts21">For example, when you need to create a jump over a pit, you first draw a long row of the </span><span class="rvts29">R</span><span class="rvts21"> button presses, and you don't care that at the same time the FCEUX screen displays how Mario runs and falls into the pit. You just draw some </span><span class="rvts29">A</span><span class="rvts21"> buttonpresses, then look at the emulator window and erase or draw additional </span><span class="rvts29">A</span><span class="rvts21"> buttonpresses, thus changing the beginning and the duration of the jump while watching the trajectory of Mario sprite.</span></p>
<p class="rvps10"><span class="rvts21">So, the process of polishing the Input in this method is a simultaneous editing and watching the segment. TASer gets in close informational contact with the game and soon starts to think synchronously with its responses. The game starts to help you filter and accept decisions. As a result, you may lose impartiality of your mind and stick to obvious decisions encouraged by the game. That's why you shouldn't use this method all the time, it's recommended to alternate it with the previous one.</span></p>
<p class="rvps10"><span class="rvts21"><br/></span></p>
<p class="rvps10"><span class="rvts21">Like with the simple nonlinear method, you can change the speed of emulation and get different variations of the semiautomatic method:</span></p>
<ol style="text-indent: 30px; margin-left: 0px; list-style-position: inside;">
<li class="rvps10"><span class="rvts21">editing and watching the changes in real time</span></li>
<li class="rvps10"><span class="rvts21">editing and watching the changes in slow motion</span></li>
<li class="rvps10"><span class="rvts21">editing and instantly seeing the final result (turbo)</span></li>
</ol>
<p class="rvps10"><a name="turbo-seeking"></a>
<span class="rvts21"><br/></span></p>
<p class="rvps10"><span class="rvts21">Turbo-seeking creates an association between two distant events (the beginning and the end of the segment). Here the association is even more efficient, because there's even less intermediaries – the seeking starts before you even release the mouse button when drawing the Input. So you see the distant result almost at the same time you change the decisive Input, even if the game normally only shows the result in a several seconds.</span></p>
<p class="rvps10"><a name="LuckManipulation"></a>
<span class="rvts21">A good example would be the process of searching for the first possible frame of pressing the </span><span class="rvts29">Start</span><span class="rvts21"> button. Some games actually allow to press the button before there's even any graphics on screen. Besides, after the </span><span class="rvts29">Start</span><span class="rvts21"> button is activated, games often meditate for some time, not giving you any information if the button worked or not. Only after a second or two you can see the changes in the scenery, thus learning the buttonpress was successful.</span></p>
<p class="rvps10"><span class="rvts21">In the traditional method of TASing you would need to spend 5-10 minutes on examination of approaches (searching for the very first frame), but the semiautomatic method allows to go over all the approaches much faster:</span></p>
<ul style="text-indent: 30px; margin-left: 0px; list-style-position: inside;">
<li class="rvps10"><span class="rvts21">Switch on the </span><span class="rvts21">"Auto-restore last position" and </span><span class="rvts21">"Turbo seek" checkboxes. Switch off the </span><span class="rvts21">"Follow cursor" checkbox.</span></li>
</ul>
<ul style="text-indent: 30px; margin-left: 0px; list-style-position: inside;">
<li class="rvps10"><span class="rvts21">Set a trial </span><span class="rvts29">Start</span><span class="rvts21"> button press at the frame where it definitely works, e.g. at the frame 100.</span></li>
</ul>
<ul style="text-indent: 30px; margin-left: 0px; list-style-position: inside;">
<li class="rvps10"><span class="rvts21">Watch the game up to the frame where you can already tell by the picture that the </span><span class="rvts29">Start</span><span class="rvts21"> was successful (e.g. the screen changed to "World 1-1" text). For example, it's the frame 150. Leave the Playback cursor at this frame – this will be the end of the segment.</span></li>
<li class="rvps10"><span class="rvts21">Now remove the trial buttonpress (the FCEUX window will flash and the "World 1-1" will disappear, leaving only the title screen, since there's no more </span><span class="rvts29">Start</span><span class="rvts21"> button press).</span></li>
<li class="rvps10"><span class="rvts21">Set the </span><span class="rvts29">Start </span><span class="rvts21">buttonpress to the beginning of the segment, which is the place where you know it's too early for the buttonpress to be registered. For example, set it to the first frame of the movie. The image in the FCEUX window will flash but then still show the title screen, because the </span><span class="rvts29">Start</span><span class="rvts21"> didn't work.</span></li>
<li class="rvps10"><span class="rvts21">Hold </span><span class="rvts30">Ctrl + Shift</span><span class="rvts21"> by one hand and begin pressing </span><span class="rvts30">Insert</span><span class="rvts21"> key once per a second or so (that really depends on your computer performance). After every </span><span class="rvts30">Ctrl + Shift + Insert</span><span class="rvts21"> combination the </span><span class="rvts29">Start</span><span class="rvts21"> buttonpress moves one frame forward, and the FCEUX window shows you if the buttonpress changed the state of the game at frame 150 or not.</span></li>
<li class="rvps10"><span class="rvts21">Until the </span><span class="rvts29">Start</span><span class="rvts21"> doesn't reach the moment when the game is ready to accept the Input, the FCEUX window will show you the title screen. But when another press of </span><span class="rvts30">Ctrl + Shift + Insert</span><span class="rvts21"> moves the </span><span class="rvts29">Start</span><span class="rvts21"> to a suitable frame, the emulator will display the "</span><span class="rvts21">World 1-1" screen.</span></li>
<li class="rvps10"><span class="rvts21">This way you've found the very first frame to press the </span><span class="rvts29">Start</span><span class="rvts21"> button. Most likely the frame number will be much less than 100.</span></li>
</ul>
<p class="rvps10"><span class="rvts21"><br/></span></p>
<p class="rvps10"><span class="rvts21">In the same way you can search for an optimal duration of holding the </span><span class="rvts29">A</span><span class="rvts21"> button, trying to land at certain point. Also consider using this method for quick luck manipulation in many games. The automatic turbo-seeking works best when you deal with a single factor of optimality and need to quickly test a hundred of similar approaches.</span></p>
<p class="rvps10"><span class="rvts21">In general, the semiautomatic method induces you to think less and experiment more. Sure, many videogames allow this way of solving tasks, but TASing requires more from you, so try not to take a fancy to the comfort of this method.</span></p>
<p class="rvps10"><span class="rvts21"><br/></span></p>
<hr style="height: 1px; color : #000000;  background-color : #000000; border-width : 0px;"/>
<p class="rvps10"><span class="rvts21"><br/></span></p>
<p class="rvps10"><span class="rvts21">Pros of the method:</span></p>
<p class="rvps14"><span class="rvts22">+ </span><span class="rvts21">Instant navigation and high</span><span class="rvts21"> speed of the working process incites to conduct more tests.</span></p>
<p class="rvps14"><span class="rvts22">+ </span><span class="rvts21">Constant feedback allows to adapt to the game while editing the Input, adjust your decisions and discard incorrect approaches prematurely.</span></p>
<p class="rvps14"><span class="rvts22">+ </span><span class="rvts21">Possibility to skip useless scenes.</span></p>
<p class="rvps10"><span class="rvts21"><br/></span></p>
<p class="rvps10"><span class="rvts21">Cons of the method:</span></p>
<p class="rvps14"><span class="rvts22">– </span><span class="rvts21">The insistent game feedback provokes TASer to discard some illogical but potentially advantageous approaches.</span></p>
<p class="rvps14"><span class="rvts22">– </span><span class="rvts21">Emphasis on the mouse controls.</span></p>
<p class="rvps10"><span class="rvts21"><br/></span></p>
<p class="rvps10"><span class="rvts25">When the method is recommended to use:</span><span class="rvts21"> when you need to polish the segment already knowing all of its optimality factors. E.g. for quick resyncing of the old Input this method is better than previous. Also it may be better for making an initial playthrough of a segment.</span></p>
<p class="rvps10"><span class="rvts21"><br/></span></p>
<hr style="height: 1px; color : #000000;  background-color : #000000; border-width : 0px;"/>
<p class="rvps10"><span class="rvts21"><br/></span></p>
<p class="rvps10"><span class="rvts21">Now that you know the main principles of working in Taseditor, you can begin TASing your game of interest. Practice is the best teacher, so you'll only learn all intricacies of the activity by engaging in a real development of your own TAS.</span></p>
<p class="rvps10"><span class="rvts21">After several weeks of practical TASing it's recommended to reread the 3rd and 4th chapters of this Guide, in order to understand the text on a deeper level.</span></p>
<p class="rvps10"><span class="rvts21"><br/></span></p>
<p class="rvps10"><span class="rvts21">In the next chapter: </span><a class="rvts27" href="ProgramCustomization.html">tweaking the program</a><span class="rvts21">.</span></p>
<p class="rvps10"><span class="rvts21"><br/></span></p>
<div class="rvps10"><table width="100%" border="1" cellpadding="6" cellspacing="2" style="border-color: #000000; border-style: solid;">
<tr valign="top">
<td style="border-color: #000000; border-style: solid;"><p class="rvps10"><span class="rvts25">PRACTICE: </span><span class="rvts21">Thoroughly polish the Input in the segments of your test movie. If the initial dividing appears to be wrong – just redo it on the fly.</span></p>
<p class="rvps10"><span class="rvts21">Use only the 2nd and the 3rd method of TASing, because traditional method is obsolete. Also try using turbo when suitable.</span></p>
<p class="rvps10"><span class="rvts25">Estimated time: </span><span class="rvts21">30-60 minutes.</span></p>
</td>
</tr>
</table>
</div>
<p class="rvps10"><span class="rvts21"><br/></span></p>
<p class="rvps10"><span class="rvts21"><br/></span></p>
<p class="rvps10"><span class="rvts21"><br/></span></p>
<p class="rvps10"><span class="rvts21"><br/></span></p>
<p class="rvps10"><span class="rvts21"><br/></span></p>
<p></p>
<p class="rvps8"><span class="rvts17">Created with the Personal Edition of HelpNDoc: </span><a class="rvts18" href="http://www.helpndoc.com/feature-tour/create-ebooks-for-amazon-kindle">Produce Kindle eBooks easily</a></p>
</div>
	
	<div id="topic_footer">

			<div id="topic_footer_content">
				&copy; 2011-2013 AnS</div>
		</div>
	</body>
	
</html>

